## 객체지향 프로그래밍
문제를 여러 개의 객체 단위로 나눠 작업하는 방식으로, 객체들이 유기적으로 상호작용하는 프로그래밍 이론
### 객체지향 프로그래밍 장점
* 코드 재사용성 증가
* 생산성 향상 
* 자연적인 모델링
* 유지보수 좋음
### 객체지향 프로그래밍 단점
* 개발속도 느림
* 실행속도 느림
* 코딩 난이도 상승
## 객체지향 프로그래밍 특징
**클래스**를 이용하여 `처리부분(함수)`과 `데이터 부분(변수)`을 하나의 `객체(인스턴스)`로 묶어 사용<br>
객체 지향 프로그래밍은 `캡슐화`, `추상화`, `상속`, `다형성` 네가지 특성을 가짐
### 캡슐화
`캡슐화`란 데이터 코드의 형태를 외부로부터 알 수 없게하고, 데이터 구조와 역할, 기능을 하나의 캡슐형태로 만드는 방법
<br><br>
변수를 private로 선언하여 데이터를 보호하고, 보호된 변수는 getter이나 setter등의 메소드를 통해서 간접적으로 접근을 허용
<br><br>
*캡슐화와 정보은닉이 같은 개념은 아니다*
### 추상화
추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
<br><br>
공통 특성을 파악해 필요없는 특성을 제거하는 과정
<br><br>
`클래스`는 객체들이 어떤 특징을 가지고 있어야 한다고 정의하는 추상화된 개념
<br><br>
객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법
### 상속
`상속`이란 기존 상위클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위클래스에 새로운 기능을 추가할 수도 있는 것
<br><br>
코드의 중복을 없애기 위해서 사용
<br><br>
상속관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없다
### 다형성
`다형성`이란 상속과 연관있는 개념으로 한 객체가 상속을 통해 기능을 확장하거나 변경하여 다른 여러형태(객체)로 재구성 되는 것<br>
쉽게 말해 *한 부모의 밑에서 태어난 자식들이 조금씩 다르다는 것*
<br><br>
오버로드(Overload) 또는 오버라이드(Override)가 다형성의 대표적인 예라 할 수 있고, 이것을 구현하는 걸 오버로딩(Overloading)과 오버라이딩(Overriding)이라 한다
<br><br>
`오버라이딩`은 하위클래스(자식)이 상위클래스(부모)에서 만들어진 메소드를 자신의 입맛대로 **재정의**하는 것<br>
`오버로딩`은 하나의 클래스 안에서 같은 이름의 메소드를 사용하지만 각 메소드마다 다른 용도로 사용되며 결과물도 다르게 구현하는 것
<br><br>
`오버로딩`이 가능하려면 메소드끼리 이름은 같지만 매개변수의 갯수나 데이터 타입이 달라야함<br>
`다형성`을 사용하면 같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고, 메소드 이름을 낭비하지 않음<br>
*API가 많아질수록 복잡성은 증가하기 때문에 `다형성`은 유용하며 코드 재사용성을 늘려주어 유지보스가 용이하도록 도와주는 개념*
## 클래스 선언 및 객체생성
### 클래스 선언
```java
public class 클래스이름 {

}
public class Car {

}
```
객체 생성
```java
클래스 변수 = new 클래스;
Car car = new Car();
```
## 클래스의 구성요소
### 필드
필드는 객체의 고유 데이터, 객체가 가져야할 부품
```java
public class Car{
  String company;
  String model;
  String color;
  int maxSpeed;
  
  int speed;
  int rpm;
}
```
필드 사용
```java
Car myCar = new Car(); //객체 생성
myCar.speed = 60; //필드 사용
```
### 생성자
생성자는 **new 연산자를 통해서 인스턴스를 생성할때 반드시 호출이 되고 제일 먼저 실행되는 일종의 메소드** *(하지만 메소드와는 다르다)* 생성자는 인스턴스변수를 초기화시키는 역할을 함
#### 생성자 선언
```java
  public 클래스(매개변수){
  
  }
```
클래스와 생성자의 이름은 동일해야 한다<br>
생성자를 생략하면 컴파일러가 자동적으로 기본 생성자(default constructor)를 생성
*디폴트 생성자란 public 클래스(){}를 의미한다*
#### 생성자 사용(필드 초기화)
```java
  public class Korean {
    //필드
    String nation = "대한민국";
    String name;
    String ssn;
    
    //생성자
    public Korean(){
    
    }
    //매개변수 있는 생성자
    public Korean(String n, String s){
      name = n;
      ssn = s;
    }
  }
```
```java
  Korean k1 = new Korean("박자바", "011225-1234567");
  Korean k2 = new Korean("김자바", "939393-1234567");
```
생성자의 매개변수를 다르게 설정하는 것을 `생성자 오버로딩`이라 한다
#### this
생성자와 메소드 매개변수 이름이 같을 때 this를 사용함으로써 필드의 변수임을 알려줌
### 메소드
* 메소드는 객체의 동작에 해당
* 필드를 읽고 수정하고 다른 객체를 생성해서 다양한 기능을 수행
* 외부로부터 매개값을 받을수도 있고, 실행 후 어떤 값을 리턴 할 수 있다
#### 메소드 선언
```java
  리턴타입 메소드이름(매개변수 선언){
    실행할 코드
  }
```
```java
  //리턴값이 없는 메소드
  void sum(){
    System.out.println(10+20);
  }
```
메소드 호출은 `객체명.메소드명(매개변수)`<br>
#### 메소드 오버로딩
* 클래스 내에 같은 이름의 메소드를 여러개 선언 하는 것을 `메소드 오버로딩`이라 한다
* `매개변수 타입`, `매개변수의 개수`, `매개변수의 순서` 중 하나가 달라야 한다
